/*
 * Licensed Materials - Property of Simon Johnston (simon@johnstonshome.org)
 * (c) Copyright Simon Johnston 2009. All rights reserved.
 * 
 * For full license details, see the file LICENSE included in the
 * distribution of this code.
 * 
 */
package com.googlecode.acpj.services;

import com.googlecode.acpj.actors.Actor;
import com.googlecode.acpj.actors.ActorFactory;
import com.googlecode.acpj.channels.BufferedChannel;
import com.googlecode.acpj.channels.Channel;
import com.googlecode.acpj.channels.ChannelFactory;
import com.googlecode.acpj.channels.ChannelRegistry;

/**
 * <p>
 * A pre-built, simple, service that monitors all the events generated by the 
 * actor runtime that denote the birth and death of actors.
 * </p>
 * 
 * @author Simon Johnston (simon@johnstonshome.org)
 * @since 0.1.0
 * 
 */
public class WatchdogService {
	
	public static final String CHANNEL_NAME = "com.googlecode.acpj.services.NotificationChannel";
	public static final String ACTOR_NAME = "com.googlecode.acpj.services.WatchdogActor";
	
	private static Channel<ActorStateMessage> watchdogChannel = null;
	private static Actor watchdogActor = null;
	private static Object serviceLock = new Object();
	
	public static void start() {
		synchronized (serviceLock) {
			if (watchdogActor == null || !watchdogActor.isRunning()) {
				watchdogChannel = ChannelFactory.getInstance().createAnyToOneChannel(CHANNEL_NAME, BufferedChannel.BUFFER_CAPACITY_UNLIMITED);
				ChannelRegistry.getInstance().register(watchdogChannel, CHANNEL_NAME,true);
				watchdogActor = ActorFactory.getInstance().createActor(new WatchdogServiceActor(watchdogChannel.getReadPort(false)), ACTOR_NAME);
			}
		}
	}

	public static void stop() {
		synchronized (serviceLock) {
			if (watchdogActor != null && watchdogActor.isRunning()) {
				ChannelRegistry.getInstance().deregister(CHANNEL_NAME);
				watchdogChannel.poison();
				watchdogChannel = null;
				watchdogActor = null;
			}
		}
	}
}
