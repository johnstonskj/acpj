The ACP project is an attempt to bring together three ideas into a coherent library for developing concurrent applications in Java. Note that bringing these concepts together enhances the ability of each model to assist the developer in writing concurrent applications, the details of this synergy are outlined below.

1. Actors provide lightweight processes in a similar way to Erlang and Scala.
2. Channels provide communication paths connecting Actors.
3. Ports provide the mechanism to control access to channels.

With the growing understanding that the next major move in application programming is to take advantage of the new multi-core world we live in where even the most basic computer these days has a multi-core CPU and possibly even a heterogeneous processor environment where the programmer can take advantage of both CPU and GPU. The rise in interest of languages such as Erlang that provides a coherent model for developing safe concurrent software, the addition to the Scala language of an actor model based on Erlang shows how this trend is spreading out in both understanding and implementation.

In looking at how processes communicate we know that the use of low-level primitives such as Threads, Semaphores, Locks and Monitors are error-prone and hard to verify. To this end Erlang supports the notion that every actor has a mailbox that other actors can write to and the owning actor can read from. This simple concurrency model is extremely valuable but can be cumbersome in modeling some real-world problems where communication is not point-to-point. In this way the Communicating Sequential Processes (CSP) model is in many ways superior as it provides a formal and concrete formalism with a set of useful abstractions for communication such as the one-to-one, one-to-any, any-to-one and any-to-any channels along with the notion of channel buffering (or not), channel poisoning and more.

However, in many implementations of CSP abstract notions into Java (and other languages) tend to focus on the implementation of the channel itself and simply provide methods on the channel to get a reader and/or writer for the processes involved to send and receive messages. The issue is that many systems need additional control over the access to a channel, and while stating that a channel is one-to-one is useful in disallowing multiple processes to write to the same channel we might want to be able to limit the number of messages allowed to be sent or by whom.

In the Mach kernel all IPC takes place using Ports, where a Port in this context is akin to a CSP any-to-one buffered channel. The key is that ports, or rather port rights can be passed around a network, so I can send you, via one port, a port right to another port allowing you to now send to or receive from that port. Another key notion in Mach is that one of these port rights is SEND_ONCE which restricts a write port to only ever sending a single message, this is particularly useful in developing callback scenarios.

To this end the ACP/J library brings together these three ideas and blends them into a coherent set of abstractions so that the strengths of each can be enhanced by the others. In particular we introduce the notion of Port as the concrete realization of the channel end-point abstraction and provide separate implementations for ReadPort and WritePort, but common capabilities in terms of port rights in terms of providing message limits and ownership of ports.
